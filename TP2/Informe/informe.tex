\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline
\usepackage{amsmath}
%\usepackage[ruled,vlined,linesnumbered,resetcount,algochapter]{algorithm2e}
\usepackage{algorithm2e}

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}


\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %



\begin{document}


\thispagestyle{empty}
\materia{M\'etodos Num\'ericos}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico II}
\subtitulo{Tirate un qu\'e, tirate un ranking...}
\integrante{Aldasoro Agustina}{86/13}{agusaldasoro@gmail.com}
\integrante{Bouz\'on Mar\'ia Bel\'en}{128/13}{belenbouzon@hotmail.com}
\integrante{Cairo Gustavo Juan}{89/13}{gjcairo@gmail.com}

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
\textcolor{blue}{El resumen de no m\'as de 200 palabras, deber\'a explicar brevemente el trabajo realizado y las conclusiones de los autores de manera que pueda ser \'util por s\'i solo para dar una idea del contenido del trabajo.} \\
\\
\\
\indent \indent \textbf{Palabras claves} \\
\\
$\circ$ Matriz Esparsa \\
$\circ$ PageRank \\
$\circ$ HITS \\
$\circ$ In-deg \\

\end{abstract}

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage


%\normalsize
\newpage

\section{Introducci\'on Te\'orica}

A la hora de dise\~nar un Motor de B\'usqueda hay varios aspectos a tener en cuenta, tales como: contar con acceso a las p\'aginas disponibles en la red, una base de datos donde almacenarlas e indexarlas para su procesamiento posterior y luego tener la capacidad de ordenarlas de acuerdo a su importancia relativa dentro de la red. Nuestro trabajo se va a centrar en este aspecto \'ultimo.

Existen varios m\'etodos los cuales priorizan distintas caracter\'isticas para dar cierto orden a una red de p\'aginas acorde con determinada b\'usqueda. Por ejemplo, uno podr\'ia ser situar en una posici\'on m\'as alta a aquellas p\'aginas que contengan mayor cantidad de coincidencias con el string de b\'usqueda. Esto podr\'ia no ser lo \'optimo, por ejemplo, si se buscara el string \textit{``Red Social''}, uno esperar\'ia que entre los `ganadores' de esta b\'usqueda se encuentren determinadas Redes Sociales como Facebook o Twitter, sin embargo la cantidad de veces que estas p\'aginas contienen al string \textit{``Red Social''} es muy peque\~na o nula y esto provocar\'ia que no aparezcan en los primeros lugares las p\'aginas deseadas.

Todos los m\'etodos a desarrollar en este trabajo se basan en comparar los Links Salientes/Entrantes dentro de la Red y otorgarles cierto orden en base a esto.
\\
\subsection{PageRank, HITS, In-deg}
El trabajo consistir\'a en estudiar distintos aspectos de los siguientes m\'etodos: PageRank,
HITS e In-deg. \\
\\
\\
\indent \indent \emph{\textbf{PageRank} - Modelo del Navegante Aleatorio} \\
\indent Este m\'etodo consta de tres fases: explorar la web y localizar todas las p\'aginas de acceso p\'ublico; indexar los datos desde el primer paso, as\'i se puede acceder eficientemente a palabras claves o frases relavantes; y valorar la importancia de cada una de las p\'aginas en la base de datos. A nivel de nuestro desarrollo, s\'olo nos vamos a encargar de la \'ultima etapa: estimar un orden de importancia para los datos.\\
\indent Teniendo un grafo dirigido, se le otorga a cada componente $X_k$ del mismo, un valor dado por la siguiente ecuaci\'on:
\[
 X_k = \sum_{j \epsilon L_k} \frac{X_j}{n_j}
\]
Donde\emph{ $L_k$} es el conjunto de links entrantes a la p\'agina k y \emph{$n_j$} es el n\'umero de links salientes desde la p\'agina j.\\
\indent Luego, se construye una matriz (que llamaremos A), donde se encuentran -por filas- las respectivas ecuaciones para cada $X_i$ como la descripta arriba.\\
\indent La resoluci\'on de este m\'etodo consiste en hallar el autovector con autovalor asociado 1 para la matriz A. De acuerdo al trabajo de Bryan y Leise \textcolor{red}{ACA PONER EL NUMERO DE REFERENCIA DE LA BIBLIOGRAFIA DONDE ESTE ESTE PAPER.}, este c\'alculo se computa mediante el m\'etodo de la potencia. \\
\indent La matriz A cuenta con ciertas mejoras para determinados casos espec\'ificos. Por un lado, si alguna p\'agina p no tuviera ning\'un link saliente se considera que tiene igual probabilidad de ir a cualquiera de las otras p\'aginas y se le otorga al vector columna p de la matriz A el valor de $\frac{1}{n}$ para cada componente. Por otro lado, existe un fen\'omeno denominado \textit{``Teletransportaci\'on''} que consiste en que un navegante se mueva de una p\'agina a otra pero no mediante los links existentes, sino tipeando la URL. Para modelar de manera \'optima este suceso, se reemplaza a la matriz A por la matriz M definida bajo la siguiente ecuaci\'on: \textit{M = (1-m)A + m.S} siendo m la probabilidad de que un navegante se \textit{teletransporte} y S una matriz cuyos valores $S_{ij}$ tienen todos el mismo valor: $\frac{1}{n}$ representando as\'i una matriz donde la probabilidad de ir a cualquier p\'agina del gr\'afico es uniforme.\\
\indent El\emph{ M\'etodo de la Potencia} se realiza de manera iterativa lo cual permite reducir el tiempo de c\'omputo para elevar a la k la matriz M. Si tenemos en cuenta el trabajo de Kamvar \textcolor{red}{ACA PONER EL NUMERO DE REFERENCIA DE LA BIBLIOGRAFIA DONDE ESTE ESTE PAPER.}, presenta una herramienta de c\'alculo que permite encontrar el principal autovector de M en una serie menor de pasos modificando la ecuaci\'on de la matriz M.\\
\\
\\
\indent \indent \emph{\textbf{Hyperlink-Induced Topic Search (HITS)}} \\
\indent El m\'etodo planteado por Kleinberg \textcolor{red}{ACA PONER EL NUMERO DE REFERENCIA DE LA BIBLIOGRAFIA DONDE ESTE ESTE PAPER.} consiste en: Dada una consulta sobre $\sigma$, nos queremos focalizar en una colecci\'on de p\'aginas $S_\sigma$ tal que sea relativamente peque\~na, sea rica en p\'aginas relevantes sobre el tema y contenga la mayor\'ia de las autoridades m\'as fuertes sobre el tema. Considerando autoridad a una p\'agina que tiene la mayor cantidad de links entrantes. Esto se realiza del siguiente modo:\\
a) Acorde a un par\'ametro \emph{t}, se coleccionan las primeras t p\'aginas rankeadas bajo una b\'usqueda basada estrictamente por texto. A este conjunto se lo llama $R_\sigma$. \\
b) Incrementamos el conjunto $R_\sigma$ a\~nadiendo las p\'aginas que tienen links entrantes y salientes al mismo, formando as\'i el conjunto $S_\sigma$. Para cada p\'agina de $R_\sigma$ se permite a\~nadir, a lo sumo \emph{d} p\'aginas que la apunten y \emph{d} p\'aginas a las cuales apunte. \\
c) Se eliminan de $S_\sigma$ los links intr\'insecos, es decir no se tienen en cuenta links que apuntan a una p\'agina del mismo dominio que la p\'agina saliente. \\
d) Admite hasta \emph{m} p\'aginas del mismo dominio apuntar a cualquier p\'agina p. Esta idea no fue utilizada por el autor. \\
\indent El conjunto obtenido hasta aca lo llamamos $G_\sigma$. Nuestro trabajo asume un conjunto $G_\sigma$ bien formado y comienza el trabajo desde aqu\'i.\\
\indent Se construye una matriz de adyacencia que denominaremos A, bajo la siguiente f\'ormula:
\[
   a_{ij} = 
   \begin{cases} 
      1              & \exists$\textit{ link desde i hasta j}$   \\
      0 & $\textit{caso contrario}$
   \end{cases}
\]
\indent A cada p\'agina i de la Web se le otorga un peso como Autoridad y un peso de Hub: \\
\indent \underline{Peso de autoridad:}
\[
	X_j = \sum_{i: i\rightarrow j}^{} Y_i
\]
\indent \underline{Peso de Hub:}
\[
Y_i = \sum_{j: i\rightarrow j} X_j
\]
\\
Este algoritmo devuelve dos arreglos: uno representa los pesos de Hub y otro los pesos de Autoridad, teniendo una coordenada para cada p\'agina perteneciente al conjunto $G_\sigma$.\\
\\
\\
\indent \indent \emph{\textbf{In-deg}} \\
\indent Consiste en definir el ranking de las p\'aginas utilizando solamente la cantidad de ejes entrantes a cada una de ellas, orden\'andolos en forma decreciente.\\

\newpage
\section{Desarrollo}
\textcolor{blue}{
Deben explicarse los m\'etodos num\'ericos que utilizaron y su aplicaci\'on al problema
concreto involucrado en el trabajo pr\'actico. Se deben mencionar los pasos que siguieron
para implementar los algoritmos, las dificultades que fueron encontrando y la
descripci\'on de c\'omo las fueron resolviendo. Explicar tambi\'en c\'omo fueron planteadas
y realizadas las mediciones experimentales. Los ensayos fallidos, hip\'otesis y conjeturas
equivocadas, experimentos y m\'etodos malogrados deben figurar en esta secci\'on, con
una breve explicaci\'on de los motivos de estas fallas (en caso de ser conocidas).\\
}
\\
\subsection{Elecci\'on de las estructuras}

 Con el fin de elegir la estructura que representar\'ia nuestra matriz esparsa, estudiamos tres tipos proporcionados por la c\'atedra: \textit{Dictionary of Keys} (DOK), \textit{Compressed Sparse Row} (CSR) y \textit{Compressed Sparse Column} (CSC). \\
\indent La primera consiste en un diccionario con doble clave (fila y columna) y su significado son los elementos de la matriz distintos de cero. De esta manera se saca provecho de la cantidad de elementos nulos de la matriz, garantizando una optimizaci\'on en t\'erminos de espacio en memoria. Adem\'as esta implementaci\'on cuenta con la gran ventaja de que resulta simple construirla incrementalmente en un arreglo esparso y adem\'as puede ser traspuesta de manera sencilla (inviertiendo el orden de las claves). Sin embargo, el principal inconveniente reside en la necesidad de convertirla a otro formato para procesar los c\'alculos aritm\'eticos. A causa de esto fue descartada la opci\'on. \\
\indent El modo de almacenamiento \textit{Compressed Sparse Row} requiere la implementacion de tres arreglos (en nuestro caso vectores) que llamaremos val, ind_col y ptr_fila. El tamaño de los dos primeros est\'a dado por la cantidad de elementos no nulos de la matriz. Mientras que el primero (val) almacena estos valores de izquierda a derecha y luego desde arriba hacia abajo, el segundo vector (ind_col) indica el n\'umero de columna para cada elemento. En otras palabras, el elemento almacenado en la posici\'on i- \'esima del vector ind_col representa la columna correspondiente al valor almanacenado en val$_i$. Por \'ultimo el tercer vector (ptr_fila) tiene un tama\~no equivalente a la cantidad de filas incrementada en uno, conteniendo los \'indices del comienzo de cada fila.\\
\indent El modo de almacenamiento \textit{Compressed Sparse Column} cuenta tambi\'en con la implementaci\'on de tres arreglos llamados: val, ind_fila, ptr_col. El primero contiene todos los valores distintos de cero de la matriz, desde arriba hacia abajo y luego de izquierda a derecha. Ind_fila son los \'indices de fila correspondientes a dichos valores.  Por \'ultimo, ptr_col lista los \'indices donde comienza cada columna.\\
\indent Por \'ultimo, el tama\~no del vector ptr_fila se encuentra determinado por la cantidad de filas incrementada en uno, y lista los \'indices que indican los valores de val que comienzan cada fila.\\

 Ante a la disyuntiva acerca de cu\'al de estos \'ultimos formatos escoger (CSR o CSC) decidimos realizar una serie de c\'alculos peque\~nos que nos permitieron notar que si nos situ\'abamos en el formato de \textit{Compressed Spare}, trasponer una matriz almacenada de manera CSC no ser\'ia m\'as que interpretar sus mismos arreglos como CSC. Se incluye un ejemplo en \emph{Ap\'endice C}. Fue decisi\'on del grupo considerar el formato por defecto de la matriz el CSR (filas) y al trasponerlas s\'olo modificarle un bool que indique si est\'a traspuesta y leerla y considerarla en adelante como CSC (columnas). Esta decisi\'on fue tomada luego de que la c\'atedra nos confirmara que estaba permitido elegir una opci\'on de las ofrecidas y adaptarla a nuestra provecho, siempre que se aclararan los cambios. Por este motivo, en el algoritmo de multiplicar una matriz por un vector se diferencia la manera en que la misma se encuentre almacenada y se obtiene el producto acorde a su formato. Se incluye el pseudoc\'odigo de este algoritmo en la Subsecci\'on \emph{Algoritmo multiplicaci\'on de una matriz por un vector}. \\

\newpage
\subsection{Algoritmo multiplicaci\'on de una matriz por un vector}
 Considerando la estructura elegida, nos vemos obligados a diferenciar dentro del algoritmo de multiplicaci\'on de una matriz por un vector acorde al modo en que debe ser le\'ido (CSR/CSC).\\
 \\
\indent Para computar el c\'alculo de una matriz por un vector ley\'endolo bajo la estructura \emph{Compressed Sparse Row} se utiliz\'o el siguiente algoritmo: \\
\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

\Input{Matriz m, Vector v}
\Output{Vector res}
\BlankLine
\For{$i\leftarrow 0$ \KwTo $cantidad$ $de$ $filas$}{
inicio $\leftarrow$ m.ptr_fil[i]\\
fin $\leftarrow$ m.ptr_fil[i+1]\\
\For{$j\leftarrow inicio$ \KwTo $fin$}{
col $\leftarrow$ m.ind_col[j]\\
res[i] $\leftarrow$ res[i] + (m.val[j] * v[col])\\
}
}
\end{algorithm}\DecMargin{1em}
\\
\textit{Se va recorriendo el vector ptr_fil de la matriz, el cual indica en qu\'e \'indice comienza cada fila. Para cada elemento de la fila actual, se asigna en el int col el n\'umero de columna correspondiente; y luego, se multiplica ese elemento con el correspondiente del vector v (v[columna actual]) y se suma en res[i], siendo i la fila actual.}
\\
 \\
 \\
  \indent Y para computar el c\'alculo de una matriz por un vector ley\'endolo bajo la estructura \emph{Compressed Sparse Column} se utiliz\'o el siguiente algoritmo: \\
   \\
\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

\Input{Matriz m, Vector v}
\Output{Vector res}
\BlankLine
\For{$i\leftarrow 0$ \KwTo $cantidad$ $de$ $filas$}{
inicio $\leftarrow$ m.ptr_fil[i]\\
fin $\leftarrow$ m.ptr_fil[i+1]\\
\For{$j\leftarrow inicio$ \KwTo $fin$}{
fil $\leftarrow$ m.ind_col[j]\\
res[col] $\leftarrow$ res[fil] + (m.val[j] * v[i])\\
}
}
\end{algorithm}\DecMargin{1em}
\\

\textit{Se va recorriendo el vector ptr_fil de la matriz, el cual indica en qu\'e \'indice comienza cada columna. Para cada elemento de la columna actual, se asigna en el int fil el n\'umero de fila correspondiente; y luego, se multiplica ese elemento con el correspondiente del vector v (v[fila Actual]) y se suma en res[fil].}\\


\newpage
\subsection{Algoritmo de HITS}

\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

\Input{Matriz m, double tol}
\Output{Vector x, Vector y}
\BlankLine

Inicializar vectores \emph{x} e \emph{y} con 1 en todas sus posiciones\\
Vector xp, yp\\
\While{(No se haya llegado a la cantidad m\'axima de iteraciones i)}{

m.$trasponer()$ \\
xp $\leftarrow$ a.$multMatVect(y)$ \\
xp.$normalizar()$ \\
m.$trasponer()$ \\
yp $\leftarrow$ a.$multMatVect(x)$ \\
yp.$normalizar()$ \\
\eIf{(xp $\simeq$ x $\wedge$ yp $\simeq$ y)}{ 
			i $\leftarrow$ M\'axima Iteraci\'on
		}{
			i++
		}
x $\leftarrow$ xp \\
y $\leftarrow$ yp \\
}
print \emph{x} e \emph{y}
\end{algorithm}\DecMargin{1em}
\textit{La cantidad m\'axima de iteraciones la fijamos nosotros en 100.000 \\
El $\simeq$ considera la tolerancia (tol) pasada por parametro. Es decir, es equivalente a evaluar abs(x-xp)$\leq$tol} \\
\textcolor{red}{Hay que poner algo sobre que copiamos el algoritmo del paper?}
\newpage
\subsection{Algoritmo de PageRank}

\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

\Input{Matriz m, double c, double tol}
\Output{x}
\BlankLine

Se inicializa el vector x en todos unos \\
Vector xp\\
\While{(No se haya llegado a la cantidad m\'axima de iteraciones i)}{
xp $\leftarrow$ m.$MultMatVec(x)$ \\
\For{$i\leftarrow 0$ \KwTo $tama$\textit{\~n}$o$ $de$ $xp$}{
xp[i] $\leftarrow$ xp[i] * c \\
\textcolor{red}{No s\'e cual forma poner ahora :(} \\
\eIf{(xp $\simeq$ x)}{ 
			i $\leftarrow$ M\'axima Iteraci\'on
		}{
			i++
		}
x $\leftarrow$ xp
}
}
normalizar el vector \emph{x} \\
print \emph{x}
\end{algorithm}\DecMargin{1em}
\textit{La cantidad m\'axima de iteraciones la fijamos nosotros en 1.000.000 \\
El $\simeq$ considera la tolerancia (tol) pasada por parametro. Es decir, es equivalente a evaluar abs(x-xp)$\leq$tol} \\
\textcolor{red}{Hay que poner algo sobre que copiamos el algoritmo del paper?}


\newpage
\section{Resultados y discusi\'on}
\textcolor{blue}{Deben incluir los resultados de los experimentos, utilizando el formato m\'as adecuado
para su presentaci\'on. Deber\'an especificar claramente a qu\'e experiencia corresponde
cada resultado. No se incluir\'an aqu\'i corridas de m\'aquina.\\
Se incluir\'a aqu\'i un an\'alisis de los resultados obtenidos en la secci\'on anterior (se analizar\'a su validez, coherencia, etc.). Deben analizarse como m\'inimo los items pedidos en el enunciado. No es aceptable decir que los resultados fueron los esperados", sin hacer
clara referencia a la teorica a la cual se ajustan. Adem\'as, se deben mencionar los resultados
interesantes y los casos "patologicos" encontrados.
}
\\
\subsection{Convergencia de PageRank}
Estudiar la convergencia de PageRank, analizando la evoluci\'on de la norma Manhattan
(norma L1) entre dos iteraciones sucesivas. Comparar los resultados obtenidos para
al menos dos instancias de tama\~no mediano-grande, variando el valor de c. Opcional:
Establecer una relaci\'on con la proporci\'on entre lambda 1 = 1 y modulo de lambda 2.

\subsection{Convergencia de HITS}
2. Estudiar la convergencia de los vectores de peso x e y para HITS de forma similar al
punto anterior.

\subsection{Factor Temporal}
3. Estudiar el tiempo de c\'omputo requerido por PageRank y HITS. Si bien ambos pueden
se aplicados sobre una red gen\'erica, cada algoritmo tiene un contexto particular de
aplicaci\'on. Estudiar como impacta el factor temporal en este sentido.

\subsection{Comparaci\'on de los tres M\'etodos}
4. Estudiar cualitativamente los rankings obtenidos por los tres m\'etodos. Para ello, se sugiere
considerar distintos ejemplos de b\'usquedas de p\'aginas web4. Analizar los resultados
individualmente en una primera etapa, y luego realizar un an\'alisis comparativo entre
los tres rankings obtenidos.

\subsection{Peque\~nos Ejemplos}
5. Para cada algoritmo, proponer ejemplos de tama\~no peque\~no que ilustren el comportamiento
esperado (puede ser utilizando las instancias provistas por la c\'atedra o generadas
por el grupo).
\newpage
\section{Conclusiones}
\textcolor{blue}{Esta secci\'on debe contener las conclusiones generales del trabajo. Se deben mencionar
las relaciones de la discusi\'on sobre las que se tiene certeza, junto con comentarios
y observaciones generales aplicables a todo el proceso. Mencionar tambi\'en posibles
extensiones a los m\'etodos, experimentos que hayan quedado pendientes, etc.
}
\\
\newpage
\section{Ap\'endices}
	\subsection{Ap\'endice A}
%----LO COMENTO PARA QUE NO MOLESTE	
%		\input{tp2}
\newpage
	\subsection{Ap\'endice B}
Se adjunta aqu\'i el algoritmo realizado para insertar, de a un elemento, los valores distintos de cero de una matriz en nuestra matriz esparsa: \\

\IncMargin{1em}
\begin{algorithm}
\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

\Input{Int fil, Int col, Double elem}
\Output{Void}
\BlankLine

i $\leftarrow$ \'indice donde comienza la fila fil pasada como par\'ametro \\
fin $\leftarrow$ \'indice donde comienza la fila siguiente a la pasada como par\'ametro \\
Iterador itval $\leftarrow$ crear iterador del vector val \\
Iterador itcol $\leftarrow$ crear iterador del vector ind_col \\
\While{(i$<$fin $\wedge$ col$>$itcol )}{
	Avanzar los dos iteradores \\
	i++
}
\eIf{(i == tama\~no del vector ind_col)}{ 
			insertar al final de ind_col el valor col pasado como par\'ametro \\
			insertar al final de val el valor elem pasado como par\'ametro
		}{
			insertar en la posici\'on correspondiente al iterador el valor col pasado por par\'ametro en el vector ind_col \\
			insertar en la posici\'on correspondiente al iterador el valor elem pasado por par\'ametro en el vector val \\
		}
\For{$i\leftarrow fil+1$ \KwTo $cantidad de filas$}{
	ptr_fil[i] ++ 
}
\end{algorithm}\DecMargin{1em}
	\subsection{Ap\'endice C}
\textcolor{blue}{Resultados que valga la pena mencionar en el trabajo pero que sean demasiado especificos para
aparecer en el cuerpo principal del trabajo podr\'an mencionarse en sucesivos ap\'endices
rotulados con las letras may\'usculas del alfabeto romano. Por ejemplo: la demostraci\'on
de una propiedad que aplican para optimizar el algoritmo que programaron para resolver
un problema.}\\
- Va un ejemplo de que trasponer en csc es leerla como csr.\\


\newpage
\section{Referencias}
\textcolor{blue}{Es importante incluir referencias a libros, art\'iculos y p\'aginas de Internet consultados
durante el desarrollo del trabajo, haciendo referencia a estos materiales a lo largo del
informe. Se deben citar tambi\'en las comunicaciones personales con otros grupos.\\
PONER ACA LOS PAPERSSSSSSSSSSS\\
}
\\

\end{document}

%\begin{figure}
%  \begin{center}
%	\includegraphics[scale=0.66]{imagenes/logouba.jpg}
%	\caption{Descripcion de la figura}
%	\label{nombreparareferenciar}
%  \end{center}
%\end{figure}


%\paragraph{\textbf{Titulo del parrafo} } Bla bla bla bla.
%Esto se muestra en la figura~\ref{nombreparareferenciar}.



%\begin{codesnippet}
%\begin{verbatim}

%struct Pepe {

%    ...

%};

%\end{verbatim}
%\end{codesnippet}